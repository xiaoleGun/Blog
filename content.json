{"posts":[{"title":"华为搞机指北(小白向)","text":"前言21日就正式开学了，已经初二下了，一天要从7:30上到20:30，生地结业考也快了，还有四个月，以后也没时间写一篇逻辑还算清楚，内容丰富详细，涵盖许多知识的文章或博客？下次这么长的图文/博客就要暑假见了。 准备什么？小白只需要一台可以运行Windows10的电脑就好力。一些极客想要进阶操作可以准备一台安装了Mac、Ubuntu、Win的电脑 解锁 这都不会小白向也拯救不了你惹。 降级 Emui 10及以上版本需要降级，Kirin960系不需要 降级到Emui 10之前的Emui 9最后一个版本 推荐电脑系统为Windows10及以上，Mac是不能降级的，但可以解BL锁，刷GSI等、、、 打开电脑，卸载原来的华为助手，下载HiSuite Proxy和HiSuite V11.0.0.530OVE解压并安装，先不要打开，先不要打开，先不要打开。 手机进入拨号输入*#*#2846579#*#*依次进入单板信息查询–&gt;版本信息找到CVersion:是什么C00或其它的，这是运营商定制版本号。 进入Huawei Firm Finder搜索你的机型型号，找到大包小包，如图。这个对不对全凭你感觉（ 打开HiSuite Proxy，添加全量包 然后再到刚刚网站上依次将三个包点击Add Rom 手机连接电脑使用一条稳定的线，手机打开开发者模式(进入关于手机连续点击版本号5次) 点击HiSuite Proxy的Setup 它会自动弹出来华为手机助手，如果没有弹出请在桌面上打开它，一路继续允许它在手机上安装《手机助手》，然后输入验证码连接。 点击系统更新，如果前面的步骤没有出错的话，不出意外它会出现你选择的版本。 等待它下载、传入安装包到手机、手机自动安装、工厂级格式化、开机。 获取解锁码并解锁渠道1、可以在淘宝、咸鱼花个二三十获取解锁码，良心商家可能会用UAndroid给你一键解锁，但我建议你让他们给你获取解锁码，因为以防日后回锁或刷挂了，救砖之后回锁了，总之解锁码一劳永逸。 2、找酷安@某贼PY一下 上手操作安装ADB 有了解锁码就可以开始这一步了。 Win版 先点击这里下载ADB，解压到C盘根目录，如图然后在电脑的开始菜单或搜索框搜索电脑信息，进入并拉到最下选择高级系统设置 点击环境变量 在第二个对话栏(系统变量)下滑找到Path 双击进去，在右面的对话框点击新建输入%adb% 按确定返回到上一个菜单，在第二个对话栏(系统变量)，点击新建，变量名输入adb，变量值输入刚刚让你把解压后的文件夹放的路径。 按确定然后可以去Powershell or CMD测试你的环境变量力不是Mac的可以跳过去刷机篇了 Mac版 从现在开始会在Mac、Ubuntu完成写作了。因为小白篇和win通用，进阶篇需要ubuntu。 安装Homebrew，打开终端输入1/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot; 输入密码，一路y(确定)结束之后输入在终端输入 1brew install cask android-platform-tools (冷知识，不知从什么时候开始brew需要将cask放在install才可以正常安装 Linux系版 ？？？你都Linux还用教吗？ 解锁BL 解锁 解锁完BL开机出现Your device booting…都是正常现象 手机重启到Fastboot 打开你刚刚配置好的Powershell或CMD或Mac终端，输入以下命令来解锁 1fastboot oem unlock #16位数字解锁码 如果不出意外的话你的手机会进入下面的界面 使用音量键选择Yes，然后它会重启到rec格式化Data结束后重启回fastboot检查PHONE Lock是否变成PHONE Unlock 回锁 1fastboot oem relock #16位数字解锁码 部分机型可能是 1fastboot oem lock #16位数字解锁码 刷机 重点介绍如何刷入Phh Treble 开始分为小白篇和进阶篇 小白篇获取GSI 先到这里Generic System Image List随便找一个你喜欢的Android9-Android12镜像，为arm64 AB分区即可，如treble_arm64_bvS，其中的b便是AB分区再简单介绍一下基于PHH编译类型 例子: treble_arm64_bvS 分解: arm64指的是平台架构、b指的是分区类型，在这里指AB，反之为a，v是指vanilla，反之g是指gapps，S指su，反之为N 上手操作 下载好你喜欢的Gsi(华为安卓12是要使用Magisk引导的)手机重启到fastboot，打开终端输入1fastboot flash system #filename 等待完成，输入1fastboot reboot 手机会自动重启，迅速按住音量上键，进入erec，选择格式化Data，输入yes 格式化完了以后就可以进入系统了(仅限Kirin960和Kirin970的安卓12以下，Kirin970的安卓12需要执行一遍Root才可以开机) 进阶篇 如果你追求极致性能，且对system分区没有读写需求的话，我们可以让system分区成为EROFS分区格式。 这一步我只简单叙述。 不仅仅适用于华为手机，对于其它手机，你的内核如果是4.19可以自己打patch启用erofs，4.19以下自行backport EROFS介绍EROFS文件系统（英文名：Enhanced Read-Only File System）是一个Linux操作系统下的只读文件系统，由华为公司研发，用来在保证嵌入式设备端到端的性能下节省存储空间，尤其是Android设备。相比其他通用文件系统，它使用了减少元数据的设计，并且提供透明压缩技术给目标文件系统用户。 上手操作 先准备好一台安装了Ubuntu20.04及以上版本的电脑，或虚拟机(虚拟机自行研究) 安装好Git 12sudo apt-get updatesudo apt-get install git lz4 python3 m4 打开终端，输入 1234mkdir tmpcd tmpwget https://github.com/xiaoleGun/Blog/releases/download/erofs/mkfs.erofs.zipunzip mkfs.erofs.zip 然后找一个你喜欢的GSI复制到tmp这个目录里如下图 继续输入 1234mkdir msudo mount -o loop,ro filename mmkdir outsudo ./mkfs.erofs -zlz4 ./out/system.img ./m 等待它将你的GSI打包为erofs分区格式然后到tmp/out目录找到它然后刷入到你的手机吧 Root 你有两个途径来获取Root，一种是在Phh treble设置–&gt;杂项–&gt;启用动态超级用户，另一种是将Rec替换为Magisk。 我主要讲解Magisk的方式，第一种就是一个选项，很简单 上手操作 下载Magsik(可能需要挂t) 打开终端输入 12fastboot flash recovery_ramdisk filenamefastboot reboot 迅速按音量上键进入erec格式化Data 解释: 只是套用华为机制的小伎俩，使重启也不会掉Magisk，原理是erec格式化Data需要重启至rec，但rec分区已经被我们替换为Magisk，所以它每次开机都会记住它需要格式化Data也就默认每次进入rec，所以我们可以重启也不会掉Magisk。 进入系统如果没有Magisk请自行下载一个Magisk可能需要你修复环境。修复即可。 至于每次弹出第三方su，请下载MT管理器到systen/xbin删除su即可(暂未发现副作用) 优化 主要是换内核及调度 Kirin960点击下载盘古内核作者为@麦麦观饭爵士: Huawei P10, P10 Plus, Mate9, Mate 9 Pro骑士: Honor 9, 8Pro (v9), Huawei Nova2S, tablet M5只需要按照对应的版本下载即可下载完之后，打开终端输入 12fastboot flash kernel filenamefastboot reboot 不出意外的话，会正常开机，请到关于本机查看内核版本号是否正确。然后你需要Root，到Magisk刷入盘古内核Spectrum调度重启后打开Spectrum选择gameing，会很丝滑，但耗电+114514 Kirin970点击下载Miku Kernel下载完之后，打开终端输入 12fastboot flash kernel filenamefastboot reboot 不出意外的话，会正常开机，请到关于本机查看内核版本号是否为Miku-Snow。 安卓12专属 你需要Root，下载Scene5按照下图进行调度配置 推荐将Quickstep设置为极速模式，这样动画丝滑流畅，其它应用使用性能即可，可自行斟酌调整频率 后记写完这些东西后有一种放松的感觉，但又想到酷安还要再排版一遍便很让人麻烦，点名酷安支持Markdown！！！","link":"/post/Fuck-Huawei/"},{"title":"Project-Mushroom","text":"Miku UI 是一个基于 AOSP-CAF 的系统，专注于性能优化与和 Miku 有关的 UI 美化～ 因此，我们的项目中可能会含有大量 Miku (ミク) 元素、、 唔…！？ Wiki 设备 目前所有设备SELinux均为强制执行，CTS均过检测。 官方版Redmi Note7 Pro(violet) 维护者: Undying-yueyue 部分老版本下载链接失效属正常现象 更新日志0.9.4 1月30日 Miku内核升级到4.14.263 Miku内核同步LA.UM.9.1.r1-11500.02-SMxxx0.QSSI12.0标签 重写设备树 下载链接: GAPPS 无GAPPS 0.9.3 1月23日 升级显示与图形驱动到LA.UM.9.1.r1-11400.02-SMxxx0.QSSI12.0 重写设备树(工程量巨大，持续了18H) 下载链接: GAPPS 无GAPPS 0.9.2 木有~ 下载链接: GAPPS 无GAPPS 0.9.1 1月15日 Miku Kernel合并上游v4.14.262 依照CDD做了一些改动 切换到SkiaGL Threaded渲染后端 下载链接: GAPPS 无GAPPS 0.9 1月7日和1月12日 更新Miku内核到4.14.261 优化SEPolicy 优化skia性能 keymaster升级到4.1 暂时将指纹切换到Redfin 下载链接: GAPPS 无GAPPS 0.8.3-0.8.5 1月6日 升级Miku内核到4.14.260 Miku内核合并最新LA.UM.9.1.r1-11500-SMxxx0.0标签 UI渲染切换到vulkan然后又切换回了OpenGL，怎么想都是阿里系app的错！ 修复音频在某些应用关不掉的bug（比如酷安） 下载链接: GAPPS 无GAPPS 0.8.2 12月27日 修复GPS的一个致命问题 优化GPS体验 下载链接: GAPPS 无GAPPS 0.8.1 12月23日 同步MIUI最新prop参数改动 重新启用SettingsProvider 使用CAF温控 优化PowerHAL启动逻辑与配置 新增FPS显示 允许OTG使用所有文件系统 为EXT4启用64位inode支持 升级GPS,图形,CNE,基带,闹钟,DSP等驱动到10900标签 优化震动体验 下载链接: GAPPS 无GAPPS 0.8 12月17日和12月20日 修复不能录屏的bug 修复录屏时卡顿的bug 修复一些app卡顿的bug 更新Raven指纹到12月 下载链接: GAPPS 无GAPPS 0.7 12月15日 升级Miku Kernel到4.14.258 升级指纹模块到2.3版本 Miku Kernel优化网络性能 修复了不能加密手机的bug（默认不加密） 新增数据状态提醒 下载链接: 无GAPPS 0.6 12月8日 启用FUSE直通 修复部分游戏Fps异常的bug 更好地利用CPU一级缓存 优化内存页回收 优化Swap算法 优化存储性能 宽松CPU延迟以减少电量浪费 允许CPU进入更深状态的睡眠 优化dim layer，减少显示延迟并减少电量浪费 移除高通PM_Qos，减少电量与cpu时间的浪费 优化IRQ 优化mqueue算法，提升事件收发性能 减少最多70%的cpu电量浪费 下载链接: 无GAPPS 0.5 12月5日和12月6日 Miku Kernel合并LA.UM.9.1.r1-11400-SMxxx0.0 新增Mi音 新增多种查看息屏通知的方式 优化Sepolicy 下载链接: 无GAPPS 0.4 12月4日 Miku Kernel升级到4.14.256 完善Sepolicy 下载链接: 无GAPPS 0.3 11月26日 首次更新 下载链接: 无GAPPS 社区版Xiaomi 6X(wayne) 维护者: xiaoleGun 如遇相机无法调用图库，请点击下载图库精简版 更新日志0.9.4 1月31日 取消对power-stats-HAL的支持 启用iWlan传统模式 修复Power HAL在log中体现的error 切换CAF ANT+(一种低功耗协议) 尝试修复视频通话/彩铃，会自动挂断的现象 切换CAF thermal 从S62Pro升级thermal Blobs 在vendor删除无用的config Miku Kernel合并v4.4.301 Tag 在设备树以及内核修复了许多在log中体现的报错 更多… 下载链接: GAPPS 无GAPPS 0.9.3 1月25日和27日 恢复内核对ebpf的支持(即网速显示正常) 修复DT2W无法关闭 下载链接: GAPPS 无GAPPS 0.9.2 1月19日 构建类型升级到社区版 Miku Kernel合并v4.4.299 Tag Miku Kernel合并LA.UM.8.4.1.c25-02000-8x98.0 Tag Miku Kernel合并LA.UM.8.2.r2-05400-sdm660.0 Tag Miku Kernel合并LA.UM.9.2.c25-00600-SDMxx0.0 Miku Kernel取消了对BPF的支持(首次开机可能较以前稍慢) 切换到SkiaGL Threaded渲染后端 修复DT2W(双击唤醒) 将Tastune增加到10 将GPU空闲计时器调整至70ms GAPPS版本取消Via浏览器支持 更多优化… 下载链接: GAPPS 无GAPPS Miku Recovery 0.9 首次更新，Unofficial，1月9日 *Device 三合一 关闭Data强制加密 修复XiaomiParts 支持微信/支付宝指纹支付 同步CAF EGL symlinks 开启通话录音 将自带浏览器替换为Via浏览器(commit注明MD5) 为EXT4启用64位inode支持 使用谷歌相机精简版 *Vendor 三合一 升级GPU驱动到V502 *Kernel 启用QTI haptics 合并v4.4.298 Tag 为Android12逆向移植BPF More… 下载链接: GAPPS 无GAPPS Essential Phone(mata) 维护者: Undying-yueyue 更新日志Android-9-09底包 建议刷~ *修复底包导致的多种问题，如: 通话无声 Chrome和Edge卡死 不上本设备的热点 下载链接: 底包 0.9.2 1月17日和1月22日 取消对ebpf的支持 修复蓝牙 下载链接: GAPPS 无GAPPS 0.9.1 1月15日 Miku Kernel合并上游v4.4.299 修复夜灯和护眼模式 下载链接: GAPPS 无GAPPS 0.9 1月8日 Miku Kernel合并上游v4.4.298 从Redmi Note 7升级了一些图形Blobs 渲染管线设置为OpenGL 启用通话录音 下载链接: GAPPS 无GAPPS 0.8.2 12月27日 Miku Kernel合并上游v4.4.296 下载链接: GAPPS 无GAPPS 0.8.1 12月24日 SElinux强制执行 下载链接: GAPPS 无GAPPS 历史更新记录0.9.4 1月30日 -Miku图标工厂进货了！ 修复新增用户时，设置头像可能会卡死的bug 修复多用户下，手势异常的bug 修复无法单独设置锁屏壁纸的bug 修复少部分情况下，图标工厂崩溃的bug 优化部分动画 更多~ 0.9.3 1月23日 Miku音效！ 0.9.2 1月16日 新增多用户 重写状态栏歌词的Hook逻辑，修复在某些情况下，音乐软件不显示状态栏歌词开关的bug Miku图标工厂新增圆形形状和正方形形状 0.9.1 1月12日 修复在英文语言下不显示图标的bug 修复部分机型的“系统界面未响应”问题 优化ART的GC机制（更少的GC） 新增Miku 图标工厂 新增字体修改 修复桌面偶尔崩溃的bug 重新开放桌面的开发者设置 睡着的Miku （？ 一些适配Vendor Freeze的改动 0.9 1月7日 更新安卓版本到安卓12_R26 更新安全补丁到2022年一月份 暂时将指纹切换到redfin 0.8.3-0.8.5 1月6日 新增状态栏亮度调节 新增亮度滑块自定义 修复电池用量显示异常的bug 新增Miku音乐通知栏 新增锁屏显示歌曲封面 0.8.2 12月27日 新增通话录音（仅限非gapps版） 新增Monet引擎自定义调节 0.8.1 12月23日 新增自动重启 修复状态栏歌词无法关闭的bug 清理通知Ticker的无用代码，删除通知Ticker入口 0.8 12月17日和12月20日 从Android12-R13同步到R21 Android安全补丁更新到2021年12月5日 优化解锁动画 微调状态栏菜单内“网络”选项的布局 硬件信息新增RAM和SOC的检测 修复SafetyNet 优化SELinux，加入Miku UI自定义规则~ 0.7 12月15日 新增网速显示 新增默认铃声 升级Gboard 修复构建类型显示未知的Bug 0.6 12月8日 新增维护者和构建类型显示 同步谷歌上游对电源键改动 0.5 12月5日 更换图标 使用了基于Colorkt的Monet 桌面优化了对Colorkt Monet的支持 新增了5x6，5x7和6x6的桌面布局 在最近任务页面，新增了一键清除后台的按钮 补充部分中文翻译 修复了启动器空指针崩溃Bug 二刺螈浓度 5% up！ 0.4 12月4日 优化屏下指纹支持 优化主题资源缓存的性能 添加机器学习模型(Tensor Flow) 修复系统界面无响应的Bug 新增在多任务界面杀死App的功能 优化图标显示效果 新增临时开机动画 开放桌面的开发者调试功能 0.3 11月26日 首次更新","link":"/post/Project-Mushroom/"},{"title":"","text":"为新设备编写 Recovery 的设备树作者: Dark(xiaoleGun)时间: 2024.2.20协作者: 一些自序这篇教程中可能有些不对的地方，请各位指正，我也刚接触 Android 设备测开发两年，而且只有在节假日的时候有空一个人瞎捣鼓，为了薅 mjw 羊毛，故写这篇教程，而且我个人更推荐 Aosp Recovery 刷写第三方 ROM，TWRP 可能多多少少有些问题。Root 之类的不需要 TWRP 也可以，可以找到原机 boot 使用 Magisk 进行修补，也可以使用 KernelSU。另外我的语文功底不是很好，写不出辞藻，只能是北方地道的大白话，见谅哈 🤣/// 准备工作1.一颗勇敢的、不怕困难的强大心脏。两颗心好勇敢 – Falling in love 2.电脑配置: 硬件 需求 CPU 四核或更多 内存 8G 或更多 硬盘 至少 80G 空余空间 系统 WSL 或实体 Linux，建议 Debian 系 3.足够的空闲时间。 4.Vscode 和 🤏Linux 知识储备 5.一台完好无损的新设备。 6.设备原厂的 boot/recovery/vendor_boot 镜像。(推荐 recovery 分区，因为里面包含一些启动必须的.rc(run command)，如果没有该分区，寻找包含官方 recovery 内容的分区。值得注意的是部分设备 recovery 合并到了 boot 中，或是存在于 vendor_boot） 7.查看自己的设备出厂 Android 版本并确定用途，是用于官方 ROM 还是第三方类原生。出厂版本为 9 及以上的可以使用 twrp-11 及以上分支，9 以下使用 twrp-9 分支。 配置环境安装依赖12sudo apt updatesudo apt-get install bc bison build-essential ccache curl flex g++-multilib gcc-multilib git gnupg gperf imagemagick lib32ncurses5-dev lib32readline-dev lib32z1-dev liblz4-tool libncurses5 libncurses5-dev libsdl1.2-dev libssl-dev libxml2 libxml2-utils lzop pngcrush rsync schedtool squashfs-tools xsltproc zip zlib1g-dev xattr openjdk-11-jdk jq android-sdk-libsparse-utils python3 python2 repo 必要时可以阅读Git 和 Repo 配置 Git 和 Repo安装完依赖后，在终端执行。 12git config --global user.name &quot;your username&quot;git config --global user.email &quot;your email&quot; 同步 TWRP 源码在自己方便的地方，建立一个目录。 12mkdir twrpcd twrp 根据自己在准备工作中确定的分支同步相应的源码。 TWRP-912repo init --depth=1 -u https://github.com/minimal-manifest-twrp/platform_manifest_twrp_omni.git -b twrp-9.0repo sync TWRP-1112repo init --depth=1 -u https://github.com/minimal-manifest-twrp/platform_manifest_twrp_aosp.git -b twrp-11repo sync TWRP-12.112repo init --depth=1 -u https://github.com/minimal-manifest-twrp/platform_manifest_twrp_aosp.git -b twrp-12.1repo sync 编写设备树 最基本的开机部分我通过 Redmi K50 做示例，并选取 TWRP-12.1 分支。 解密部分会单独成一个章节并分为高通和联发科。 获取资料小米设备一般可以在Xiaomirom中的线刷包获取 boot/recovery/vendor_boot 镜像，其它设备请自行寻找。 安装工具和依赖将准备工作中准备的 boot/recovery/vendor_boot 镜像解包，可以用任何工具，我这里使用Android_boot_image_editor按照自述文件进行依赖安装操作： Mac(Intel)123brew install lz4 xz dtc openjdk@17echo 'export PATH=&quot;/usr/local/opt/openjdk@17/bin:$PATH&quot;' &gt;&gt; ~/.zshrcsource ~/.zshrc Linux:12sudo apt updatesudo apt install git device-tree-compiler lz4 xz-utils zlib1g-dev openjdk-17-jdk gcc g++ python3 python-is-python3 p7zip-full android-sdk-libsparse-utils erofs-utils Common:12git clone https://github.com/cfig/Android_boot_image_editorcd Android_boot_image_editor 解包 请注意”/“表示或的意思，请不要误以为是一个东西。 如果不确定分区寻找的是否正确，请尝试将可以的分区进行解包，并查看其ramdisk内是否包含recovery字样的文件 将你准备好的boot/recovery/vendor_boot复制到该目录，你可以使用 GUI 或者 CLI。如: 12cp &lt;出厂boot/recovery/vendor_boot的绝对路径&gt; boot/recovery/vendor_boot.img./gradlew unpack 我这里以 Redmi K50 为例 123456789101112131415161718192010:12:13.188 [main] INFO cfig.bootimg.v3.VendorBoot - Unpack Summary of vendor_boot.img┌───────────────────────────────────────┬──────────────────────────────────────┐│What │Where │└───────────────────────────────────────┴──────────────────────────────────────┘┌───────────────────────────────────────┬──────────────────────────────────────┐│image info │build/unzip_boot/vendor_boot.json │├───────────────────────────────────────┼──────────────────────────────────────┤│ramdisk │build/unzip_boot/ramdisk.img.lz4 ││-- PLATFORM ramdisk[1/1] │build/unzip_boot/ramdisk.1.lz4 ││------- extracted rootfs │build/unzip_boot/root.1 │├───────────────────────────────────────┼──────────────────────────────────────┤│dtb │build/unzip_boot/dtb │├───────────────────────────────────────┼──────────────────────────────────────┤│AVB info │build/unzip_boot/vendor_boot.avb.json ││\\-- signing key │NONE │└───────────────────────────────────────┴──────────────────────────────────────┘10:12:13.213 [main] WARN cfig.packable.PackableLauncher - 'unpack' sequence completedBUILD SUCCESSFUL in 2s 解包成功后终端会打印出以上信息，其中包含vendor_boot目录结构，我们只需要ramdisk里的部分内容就好了。 1ls build/unzip_boot/root.1 # 请根据自己的分区和设备判断ramdisk的命名，一般都直接是ramdisk 不出意外的话会输出以下内容 1234567891011121314151617181920212223242526xiaolegun@xiaoleGundeMac-Pro  ~/github/dump/bootedit   master ?  ls build/unzip_boot/root.1acct oemapex plat_file_contextsbin plat_property_contextsbugreports postinstallconfig procd productdata product_file_contextsdata_mirror product_property_contextsdebug_ramdisk prop.defaultdefault.prop resdev sdcardetc second_stage_resourcesfirst_stage_ramdisk sepolicyinit storageinit.recovery.hardware.rc sysinit.recovery.mt6895.rc systemlib system_extlinkerconfig system_ext_file_contextsmiui.factoryreset.fstab system_ext_property_contextsmiui.factoryreset.rc tmpmnt vendorodm vendor_dlkmodm_dlkm vendor_file_contextsodm_file_contexts vendor_property_contextsodm_property_contexts 如果包含 init.recovery*的字样，恭喜你成功找到了正确的分区。将这个目录复制到一个自己方便的地方。至此资料已经大致齐全了，解密的资料会在解密章节来讲解如何获取。 初始化目录结构在 twrp 源码根目录输入 123mkdir -p device/vendor/codenamemkdir -p device/vendor/codename/recovery/rootcd device/vendor/codename vendor指的是供应商，如 xiaomi、oneplus、huawei、vivo、realme。codename指的是设备代号，小米设备可以在Xiaomirom查询，其它设备自行查询亦或是在开发者选项勾选 USB 调试通过 adb 尝试获取。 12adb shell getprop ro.product.manufacturer # 供应商adb shell getprop ro.product.device # 设备代号 我的 Redmi K50 会打印以下信息 1234xiaolegun@xiaoleGundeMac-Pro  ~/github/dump/bootedit   master ?  adb shell getprop ro.product.manufacturerXiaomi # 无论打印出来的内容是大写还是小写，在目录结构中我们都采用小写xiaolegun@xiaoleGundeMac-Pro  ~/github/dump/bootedit   master ?  adb shell getprop ro.product.devicerubens 我的 IQOO NEO5 Lite 会打印以下信息 1234xiaolegun@xiaoleGundeMac-Pro  ~/github/tmp/device/xiaomi/rubens  adb shell getprop ro.product.manufacturervivoxiaolegun@xiaoleGundeMac-Pro  ~/github/tmp/device/xiaomi/rubens  adb shell getprop ro.product.devicePD2118 一般只要不是山寨机，小作坊出来的机子，用这两条命令应该是可以正确获取的。 初始化构建时必要的文件无论是 AOSP device tree 亦或是 TWRP device tree 都基本类似于以下结构。 12345678/├── prebuilt (存放kernel、dtb等预编译文件) # AOSP device tree若使用build kernel则没有该目录├── recovery/root (存放一些.rc和解密blobs) # 一般用于Recovery device tree├── Android.mk (Android构建系统首先会检查每个目录的Android.mk，里面包含一些判断，由它包括其所在目录中所有Makefile)├── AndroidProducts.mk (声明产品的Makefile和lunch时可用的构建类型)├── BoardConfig.mk (板载配置文件，定义了主板必要的Flag)├── device.mk (声明设备所需的文件和模块)└── &lt;ROM&gt;_codename.mk (声明产品特定信息，例如名称、品牌和型号，引用device.mk等) # ROM就比如lineage、arrow等，编译twrp就直接写twrp，twrp-9分支要写onmi 我们把这样的结构称为骨架树(skeleton tree)。接下来我们按照以上结构为自己的设备写一份 Recovery device tree。在终端使用touch命令创建必要的文件。 12touch Android.mk AndroidProducts.mk BoardConfig.mk device.mk twrp_rubens.mkls . 不出意外的话会打印出以下信息 1234xiaolegun@xiaoleGundeMac-Pro  ~/github/tmp/device/xiaomi/rubens  touch Android.mk AndroidProducts.mk BoardConfig.mk device.mk twrp_rubens.mkxiaolegun@xiaoleGundeMac-Pro  ~/github/tmp/device/xiaomi/rubens  ls .Android.mk BoardConfig.mk prebuilt twrp_rubens.mkAndroidProducts.mk device.mk recovery 可以下一步了~ 初始 Android.mk 文件打开 Vscode 并打开设备树目录，你足够强也可以使用 nano、vim 编辑。选中 Android.mk 并按照自己的资料复制并更改以下内容 12345LOCAL_PATH := $(call my-dir)ifeq ($(TARGET_DEVICE),codename)include $(call all-subdir-makefiles,$(LOCAL_PATH))endif codename是需要你修改的部分 我修改后是这样的 12345LOCAL_PATH := $(call my-dir)ifeq ($(TARGET_DEVICE),rubens)include $(call all-subdir-makefiles,$(LOCAL_PATH))endif 初始 AndroidProducts.mk 文件选中 AndroidProducts.mk 并按照自己的资料复制并更改以下内容 12345PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/&lt;ROM&gt;_&lt;codename&gt;.mkCOMMON_LUNCH_CHOICES := \\ &lt;ROM&gt;_&lt;codename&gt;-eng 我修改后是这样的 12345PRODUCT_MAKEFILES := \\ $(LOCAL_DIR)/twrp_rubens.mkCOMMON_LUNCH_CHOICES := \\ twrp_rubens-eng 初始 BoardConfig.mk 文件 将之前准备的ramdisk文件夹用新窗口打开 1.找到目录下的 prop.default 或含 prop 字样的文件。以下注释类似 ro.*.*的就是从 prop 中获取的 2.解包 boot/recovery/vendor_boot 的 json例如 build/unzip_boot/boot.json 选中 BoardConfig.mk 并按照自己的资料复制并更改以下内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192DEVICE_PATH := device/vendor/codename# ArchitectureTARGET_ARCH := arm64 # ro.bionic.archTARGET_ARCH_VARIANT := armv8-a # 64位默认变体TARGET_CPU_ABI := arm64-v8a # ro.vendor.product.cpu.abilist64 (至少在小米设备上没有找到ro.product.cpu.abilist)TARGET_CPU_ABI2 := # 64位留空TARGET_CPU_VARIANT := generic # 默认一般都是通用TARGET_CPU_VARIANT_RUNTIME := cortex-a55 # ro.bionic.cpu_variantTARGET_2ND_ARCH := arm # ro.bionic.2nd_archTARGET_2ND_ARCH_VARIANT := $(TARGET_ARCH_VARIANT)TARGET_2ND_CPU_ABI := armeabi-v7a # ro.vendor.product.cpu.abilist32第一个TARGET_2ND_CPU_ABI2 := armeabi # ro.vendor.product.cpu.abilist32第二个TARGET_2ND_CPU_VARIANT := $(TARGET_CPU_VARIANT)TARGET_2ND_CPU_VARIANT_RUNTIME := $(TARGET_CPU_VARIANT)# AssertationTARGET_OTA_ASSERT_DEVICE := rubens # codename# BootloaderTARGET_BOOTLOADER_BOARD_NAME := rubens # ro.product.boardTARGET_NO_BOOTLOADER := trueTARGET_USES_UEFI := true# Build RuleALLOW_MISSING_DEPENDENCIES := true # 为了recovery不健全的依赖# Kernel - 注释会说明在boot/recovery/vendor_boot.json中对应的变量BOARD_BOOTIMG_HEADER_VERSION := 4 # headerVersionBOARD_KERNEL_BASE := 0x3fff8000 # (kernelLoadAddr - 32KB) qcom设备base为0，且没有偏移(offset)BOARD_KERNEL_CMDLINE := bootopt=64S3,32N2,64N2 # cmdlineBOARD_KERNEL_PAGESIZE := 4096 # pageSizeBOARD_RAMDISK_OFFSET := 0x26f08000 # (ramdisk,loadAddr - BOARD_KERNEL_BASE)BOARD_KERNEL_TAGS_OFFSET := 0x07c88000 # (tagsLoadAddr - BOARD_KERNEL_BASE)BOARD_MKBOOTIMG_ARGS += --header_version $(BOARD_BOOTIMG_HEADER_VERSION)BOARD_MKBOOTIMG_ARGS += --ramdisk_offset $(BOARD_RAMDISK_OFFSET)BOARD_MKBOOTIMG_ARGS += --tags_offset $(BOARD_KERNEL_TAGS_OFFSET)# Kernel - prebuiltTARGET_PREBUILT_KERNEL := $(DEVICE_PATH)/prebuilt/kernel # 预编译内核相对于android源码根目录的相对路径，vendor_boot机型不需要TARGET_PREBUILT_DTB := $(DEVICE_PATH)/prebuilt/dtb.img # 同上BOARD_MKBOOTIMG_ARGS += --dtb $(TARGET_PREBUILT_DTB)# PartitionsBOARD_FLASH_BLOCK_SIZE := 262144 # (BOARD_KERNEL_PAGESIZE * 64)BOARD_BOOTIMAGE_PARTITION_SIZE := 67108864 # boot/recovery/vendor_boot镜像的字节大小需原厂或手机完整提取出来的，不定义会报错BOARD_RECOVERYIMAGE_PARTITION_SIZE := 67108864 # 同上BOARD_VENDOR_ROOTIMAGE_PARTITION_SIZE := 67108864 # 同上BOARD_SYSTEMIMAGE_PARTITION_TYPE := ext4 # 分区类型，查看ramdisk中fstab定义的类型BOARD_USERDATAIMAGE_FILE_SYSTEM_TYPE := ext4BOARD_VENDORIMAGE_FILE_SYSTEM_TYPE := ext4TARGET_COPY_OUT_VENDOR := vendor # 定义vendor目录，例如copy专有blobs要用BOARD_SUPER_PARTITION_SIZE := 9126805504 # 可以通过blockdev --getsize64 /dev/block/bootdevice/by-name/super获取，需root，如果无法root可以直接使用这个值，不影响twrp启动，可以后续修正BOARD_SUPER_PARTITION_GROUPS := xiaomi_dynamic_partitions # xiaomi根据你获取资料的vendor替换，是一个动态分区组BOARD_XIAOMI_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product system_ext odm vendor_dlkm odm_dlkm # 根据fstab内的定义，一般flag包含logical都属于动态分区组的一部分BOARD_XIAOMI_DYNAMIC_PARTITIONS_SIZE := 9122611200 # (BOARD_SUPER_PARTITION_SIZE - 4MB)# PlatformTARGET_BOARD_PLATFORM := mt6895 # ro.board.platform# Recovery - 基本通用的不影响启动BOARD_HAS_LARGE_FILESYSTEM := trueTARGET_RECOVERY_PIXEL_FORMAT := RGBX_8888TARGET_USERIMAGES_USE_EXT4 := trueTARGET_USERIMAGES_USE_F2FS := true# TrebleBOARD_VNDK_VERSION := current # 声明VNDK版本# Vendor_boot recovery ramdiskBOARD_MOVE_RECOVERY_RESOURCES_TO_VENDOR_BOOT := true # 将recovery文件复制到vendor_boot# Boot recovery ramdisk#BOARD_USES_RECOVERY_AS_BOOT := true recovery ramdisk合并在boot中启用# Verified BootBOARD_AVB_ENABLE := trueBOARD_AVB_MAKE_VBMETA_IMAGE_ARGS += --flags 3# TWRP ConfigurationsTW_DEFAULT_LANGUAGE := zh_CN # 默认为中文TW_EXTRA_LANGUAGES := true # 额外的语言TW_THEME := portrait_hdpi # 主题TW_INCLUDE_FASTBOOTD := true # 包括fastbootd，为动态分区# 其它flag还有很多，可以在https://xdaforums.com/t/twrp-flags-for-boardconfig-mk.3333970 查找，# 这篇文章也很老了，但我并不推荐twrp，所以flag我也不是很了解，多翻翻github:)# DebugTARGET_USES_LOGD := true # 调试flagTWRP_INCLUDE_LOGCAT := true 无注释版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889DEVICE_PATH := device/vendor/codename# ArchitectureTARGET_ARCH := arm64TARGET_ARCH_VARIANT := armv8-aTARGET_CPU_ABI := arm64-v8aTARGET_CPU_ABI2 :=TARGET_CPU_VARIANT := genericTARGET_CPU_VARIANT_RUNTIME := cortex-a55TARGET_2ND_ARCH := armTARGET_2ND_ARCH_VARIANT := $(TARGET_ARCH_VARIANT)TARGET_2ND_CPU_ABI := armeabi-v7aTARGET_2ND_CPU_ABI2 := armeabiTARGET_2ND_CPU_VARIANT := $(TARGET_CPU_VARIANT)TARGET_2ND_CPU_VARIANT_RUNTIME := $(TARGET_CPU_VARIANT)# AssertationTARGET_OTA_ASSERT_DEVICE := rubens# BootloaderTARGET_BOOTLOADER_BOARD_NAME := rubensTARGET_NO_BOOTLOADER := trueTARGET_USES_UEFI := true# Build RuleALLOW_MISSING_DEPENDENCIES := true# KernelBOARD_BOOT_HEADER_VERSION := 4BOARD_KERNEL_BASE := 0x3fff8000BOARD_KERNEL_CMDLINE := bootopt=64S3,32N2,64N2BOARD_KERNEL_PAGESIZE := 4096BOARD_RAMDISK_OFFSET := 0x26f08000BOARD_KERNEL_TAGS_OFFSET := 0x07c88000BOARD_MKBOOTIMG_ARGS += --header_version $(BOARD_BOOT_HEADER_VERSION)BOARD_MKBOOTIMG_ARGS += --ramdisk_offset $(BOARD_RAMDISK_OFFSET)BOARD_MKBOOTIMG_ARGS += --tags_offset $(BOARD_KERNEL_TAGS_OFFSET)BOARD_KERNEL_IMAGE_NAME := Image# Kernel - prebuiltTARGET_PREBUILT_DTB := $(DEVICE_PATH)/prebuilt/dtb.imgBOARD_MKBOOTIMG_ARGS += --dtb $(TARGET_PREBUILT_DTB)# PartitionsBOARD_FLASH_BLOCK_SIZE := 262144BOARD_BOOTIMAGE_PARTITION_SIZE := 67108864BOARD_RECOVERYIMAGE_PARTITION_SIZE := 67108864BOARD_VENDOR_ROOTIMAGE_PARTITION_SIZE := 67108864BOARD_SYSTEMIMAGE_PARTITION_TYPE := ext4BOARD_USERDATAIMAGE_FILE_SYSTEM_TYPE := ext4BOARD_VENDORIMAGE_FILE_SYSTEM_TYPE := ext4TARGET_COPY_OUT_VENDOR := vendorBOARD_SUPER_PARTITION_SIZE := 9126805504BOARD_SUPER_PARTITION_GROUPS := xiaomi_dynamic_partitionsBOARD_XIAOMI_DYNAMIC_PARTITIONS_PARTITION_LIST := system vendor product system_ext odm vendor_dlkm odm_dlkmBOARD_XIAOMI_DYNAMIC_PARTITIONS_SIZE := 9122611200# PlatformTARGET_BOARD_PLATFORM := mt6895# RecoveryBOARD_HAS_LARGE_FILESYSTEM := trueTARGET_RECOVERY_PIXEL_FORMAT := RGBX_8888TARGET_USERIMAGES_USE_EXT4 := trueTARGET_USERIMAGES_USE_F2FS := true# TrebleBOARD_VNDK_VERSION := current# Vendor_boot recovery ramdiskBOARD_MOVE_RECOVERY_RESOURCES_TO_VENDOR_BOOT := true# Boot recovery ramdisk#BOARD_USES_RECOVERY_AS_BOOT := true# Verified BootBOARD_AVB_ENABLE := trueBOARD_AVB_MAKE_VBMETA_IMAGE_ARGS += --flags 3# TWRP ConfigurationsTW_DEFAULT_LANGUAGE := zh_CNTW_EXTRA_LANGUAGES := trueTW_THEME := portrait_hdpiTW_INCLUDE_FASTBOOTD := true# DebugTARGET_USES_LOGD := trueTWRP_INCLUDE_LOGCAT := true 这块写了好久我也不确定对不对，请各位指正，尤其是 Kernel 部分。 初始 device.mk 文件 准备好 prop.default 选中 AndroidProducts.mk 并按照自己的资料复制并更改以下内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344DEVICE_PATH := device/xiaomi/rubens# APIPRODUCT_SHIPPING_API_LEVEL := 31 # ro.board.first_api_level# A/BAB_OTA_UPDATER := true # 启用A/B无缝更新AB_OTA_PARTITIONS += \\ # 定义A/B分区，参考fstab boot \\ dtbo \\ system \\ product \\ vendor \\ odm \\ odm_dlkm \\ vbmeta \\ vendor_boot \\ vendor_dlkm \\ vbmeta_system \\ vbmeta_vendorPRODUCT_PACKAGES += \\ update_engine \\ update_engine_sideload \\ update_verifier \\ checkpoint_gcAB_OTA_POSTINSTALL_CONFIG += \\ RUN_POSTINSTALL_system=true \\ POSTINSTALL_PATH_system=system/bin/mtk_plpath_utils \\ FILESYSTEM_TYPE_system=ext4 \\ POSTINSTALL_OPTIONAL_system=trueAB_OTA_POSTINSTALL_CONFIG += \\ RUN_POSTINSTALL_vendor=true \\ POSTINSTALL_PATH_vendor=bin/checkpoint_gc \\ FILESYSTEM_TYPE_vendor=ext4 \\ POSTINSTALL_OPTIONAL_vendor=true# DynamicPRODUCT_USE_DYNAMIC_PARTITIONS := true # 动态分区# Soong namespacesPRODUCT_SOONG_NAMESPACES += $(DEVICE_PATH) # 命名空间 A/B 无缝更新部分高通和联发科不一样，联发科设备可以照抄，注意 system/bin/mtk_plpath_utils 就好。高通参考venus twrp tree，并且高通的bootctrl和gpt-utils可以从 CLO 拿。 无注释版 1234567891011121314151617181920212223242526272829303132333435363738394041PRODUCT_SHIPPING_API_LEVEL := 31# A/BAB_OTA_UPDATER := trueAB_OTA_PARTITIONS += \\ boot \\ dtbo \\ system \\ product \\ vendor \\ odm \\ odm_dlkm \\ vbmeta \\ vendor_boot \\ vendor_dlkm \\ vbmeta_system \\ vbmeta_vendorPRODUCT_PACKAGES += \\ update_engine \\ update_engine_sideload \\ update_verifier \\ checkpoint_gcAB_OTA_POSTINSTALL_CONFIG += \\ RUN_POSTINSTALL_system=true \\ POSTINSTALL_PATH_system=system/bin/mtk_plpath_utils \\ FILESYSTEM_TYPE_system=ext4 \\ POSTINSTALL_OPTIONAL_system=trueAB_OTA_POSTINSTALL_CONFIG += \\ RUN_POSTINSTALL_vendor=true \\ POSTINSTALL_PATH_vendor=bin/checkpoint_gc \\ FILESYSTEM_TYPE_vendor=ext4 \\ POSTINSTALL_OPTIONAL_vendor=true# DynamicPRODUCT_USE_DYNAMIC_PARTITIONS := true# Soong namespacesPRODUCT_SOONG_NAMESPACES += $(DEVICE_PATH) 初始 twrp_rubens.mk 文件选中 AndroidProducts.mk 并按照自己的资料复制并更改以下内容 12345678910111213141516171819# Inherit from common AOSP config$(call inherit-product, $(SRC_TARGET_DIR)/product/base.mk)$(call inherit-product, $(SRC_TARGET_DIR)/product/core_64_bit_only.mk)$(call inherit-product, $(SRC_TARGET_DIR)/product/virtual_ab_ota/launch_with_vendor_ramdisk.mk) # vab加载到vendor boot里使用# Inherit from TWRP product configuration$(call inherit-product, vendor/twrp/config/common.mk) # twrp-9分支改为onmi# Device specific configs$(call inherit-product, device/xiaomi/rubens/device.mk)# Device identifierPRODUCT_DEVICE := rubens # 设备型号PRODUCT_NAME := twrp_rubens # 设备名称PRODUCT_BRAND := Redmi # 自定义品牌，如果有PRODUCT_MODEL := 22041211AC # 产品最终用户可见名称PRODUCT_MANUFACTURER := Xiaomi # 制造商PRODUCT_PROPERTY_OVERRIDES += ro.twrp.vendor_boot=true # 对twrp启动vendor_boot支持 无注释版 12345678910111213141516171819# Inherit from common AOSP config$(call inherit-product, $(SRC_TARGET_DIR)/product/base.mk)$(call inherit-product, $(SRC_TARGET_DIR)/product/core_64_bit_only.mk)$(call inherit-product, $(SRC_TARGET_DIR)/product/virtual_ab_ota/launch_with_vendor_ramdisk.mk) # vab加载到vendor boot里使用# Inherit from TWRP product configuration$(call inherit-product, vendor/twrp/config/common.mk)# Device specific configs$(call inherit-product, device/xiaomi/rubens/device.mk)# Device identifierPRODUCT_DEVICE := rubensPRODUCT_NAME := twrp_rubensPRODUCT_BRAND := RedmiPRODUCT_MODEL := 22041211ACPRODUCT_MANUFACTURER := XiaomiPRODUCT_PROPERTY_OVERRIDES += ro.twrp.vendor_boot=true 初始 recovery 目录 拿出我们好久之前准备的 ramdisk 叭 通过tree命令我们可以查看 ramdisk 的树状图，可以很清晰的查看包含的文件 1234567891011121314151617181920212223242526272829303132333435363738394041├── acct├── apex├── bin -&gt; /system/bin├── bugreports -&gt; /data/user_de/0/com.android.shell/files/bugreports├── config├── d -&gt; /sys/kernel/debug├── data├── data_mirror├── debug_ramdisk├── default.prop -&gt; prop.default├── dev├── etc -&gt; /system/etc├── first_stage_ramdisk│ ├── fstab.emmc│ ├── fstab.mt6895│ └── system│ ├── bin│ │ ├── e2fsck│ │ ├── linker64│ │ ├── linker_asan64 -&gt; linker64│ │ └── snapuserd│ └── lib64│ ├── ld-android.so│ ├── libbase.so│ ├── libc++.so│ ├── libc.so│ ├── libdl.so│ ├── libext2_blkid.so│ ├── libext2_com_err.so│ ├── libext2_e2p.so│ ├── libext2_quota.so│ ├── libext2_uuid.so│ ├── libext2fs.so│ ├── liblog.so│ ├── libm.so│ ├── libsparse.so│ └── libz.so├── init -&gt; /system/bin/init├── init.recovery.hardware.rc├── init.recovery.mt6895.rc└── 等等等等...省略大概1000个文件吧 因为避免教程时效性，我们尽可能选取 prebuilt 的办法，如 boot 和 mtk_plpath_utils 都采用预编译。 里面有很多文件是没用的，整理一下，对我们有用的只有这些 1234567891011121314151617181920212223242526272829303132333435.├── first_stage_ramdisk│ ├── fstab.emmc│ └── fstab.mt6895├── init.recovery.mt6895.rc├── lib│ └── modules│ ├── 8250_mtk.ko│ ├── adapter_class.ko│ ├── adsp.ko│ ├── aee_aed.ko│ ├── aee_hangdet.ko│ ├── aee_rs.ko│ ├── blocktag.ko│ ├── bootprof.ko│ ├── bq28z610.ko│ ├── cache-parity.ko│ ├── cfg80211.ko│ ├── charger_class.ko│ └── 省略一百多个模块，这个目录里的东西全要└── system ├── bin │ └── mtk_plpath_utils ├── etc │ ├── init │ │ │── mtk-plpath-utils.rc │ │ └──hw │ │ └──init.rc │ ├── recovery.fstab │ ├── security │ │ └── otacerts.zip │ └── ueventd.rc └── lib64 └── hw └── android.hardware.boot@1.0-impl-1.2-mtkimpl.so 将它们按照以下操作复制 first_stage_ramdisk –&gt; recovery/root/first_stage_ramdisk init.recovery.mt6895.rc –&gt; recovery/root/init.recovery.mt6895.rc lib –&gt; recovery/root/lib system –&gt; recovery/root/system (security 和 hw 文件夹里的内容作为备用，不要复制进去)得到以下目录结构 1234567891011121314151617181920212223242526272829303132.├── Android.mk├── AndroidProducts.mk├── BoardConfig.mk├── device.mk├── prebuilt├── recovery│ └── root│ ├── first_stage_ramdisk│ │ ├── fstab.emmc│ │ └── fstab.mt6895│ ├── init.recovery.mt6895.rc│ ├── lib│ │ └── modules│ │ ├── 8250_mtk.ko│ │ ├── adapter_class.ko│ │ ├── adsp.ko│ │ ├── aee_aed.ko│ │ ├── aee_hangdet.ko│ │ ├── aee_rs.ko│ │ ├── blocktag.ko│ │ └── 省略....│ └── system│ ├── bin│ │ └── mtk_plpath_utils│ ├── etc│ │ ├── recovery.fstab│ │ └── ueventd.rc│ └── lib64│ └── hw│ └── android.hardware.boot@1.0-impl-1.2-mtkimpl.so└── twrp_rubens.mk 打开 init.recovery.mt6895.rc 添加 12345on boot start health-hal-2-1on post-fs start boot-hal-1-2 例如 12345678910111213141516on post-fs start boot-hal-1-2on init setprop sys.usb.configfs 1 setprop sys.usb.controller &quot;11201000.usb0&quot; setprop sys.usb.ffs.aio_compat 1on fs &amp;&amp; property:ro.debuggable=0 # distinguish USB shoulde connect or not, i.e. CDP vs SDP # set charging free due to it wait for USB activationon boot start health-hal-2-1 exec u:r:update_engine:s0 root root -- /system/bin/mtk_plpath_utils 接下来可以开始编译咯~~ 编译 编译前请检查注释是否全部删除 twrp 源码根目录执行 123. build/envsetup.shlunch twrp_codename-eng # twrp-9为onmimka vendorbootimg/bootimage/recoveryimage 不出意外的话一路绿灯，如果有报错的话请发邮箱至 1592501605@qq.com 咨询我 产物在 out/target/product/codename/vendor_boot.img\\boot.img\\recovery.img手机重启到 fastboot 模式，使用 fastboot flash 刷写，例如 1fastboot flash vendor_boot /Users/xiaolegun/Downloads/vendor_boot.img 则输出 12345ERROR: could not clear input pipe; result e0005000, ignoring...ERROR: could not clear output pipe; result e0005000, ignoring....Sending 'vendor_boot_a' (65536 KB) OKAY [ 1.396s]Writing 'vendor_boot_a' OKAY [ 0.167s]Finished. Total time: 1.625s 就可以重启按电源加音量上尝试了，我自己是一次点亮，但有 bug。 修 BUG修复 USB我看到 twrp 控制台有很多报错，第一步肯定是先获取日志，使用logcat命令获取，在此之前先使用adb devices检测一下设备 usb 是否工作正常。 1234xiaolegun@xiaoleGundeMac-Pro  ~  adb devices  ✔  10208  10:05:31* daemon not running; starting now at tcp:5037* daemon started successfullyList of devices attached 可以看到adb没有检测到设备，原因一般是 usb 的配置不对，但 usb 是好的。这时可以尝试关闭 mtp，再开启，如果电脑有反应，那么就可以继续下一步了。在设备树中的 recovery/root，创建 init.recovery.usb.rc 的文件 1touch recovery/root/init.recovery.usb.rc 并导入以下内容 12345678910111213141516on property:sys.usb.config=mtp,adb start adbdon property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=mtp,adb write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration &quot;mtp_adb&quot; rm /config/usb_gadget/g1/configs/b.1/f1 rm /config/usb_gadget/g1/configs/b.1/f2 rm /config/usb_gadget/g1/configs/b.1/f3 rm /config/usb_gadget/g1/configs/b.1/f4 rm /config/usb_gadget/g1/configs/b.1/f5 write /config/usb_gadget/g1/idVendor 0x18d1 write /config/usb_gadget/g1/idProduct 0x2d08 symlink /config/usb_gadget/g1/functions/mtp.gs0 /config/usb_gadget/g1/configs/b.1/f1 symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f2 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config} 这是我从我维护的 MI 6X 的 device tree 拿过来的，可以在联发科设备上正常工作。这段 shell 的大致意思就是在 usb 配置节点写入 mtp 和 adb 同时工作的字符串，这样 adb 就能顺利工作了。 此外打开原厂 init.rc 修正一下 usb 设备的 id 1234567891011121314151617# MIUI ADD: STARTimport /init.recovery.hardware.rcimport /miui.factoryreset.rc# ENDimport /init.recovery.${ro.hardware}.rc########### 省略一万字# MIUI ADD: STARTon property:sys.usb.config=mtp,adb &amp;&amp; property:sys.usb.configfs=0 write /sys/class/android_usb/android0/enable 0 write /sys/class/android_usb/android0/idVendor 2717 write /sys/class/android_usb/android0/idProduct 904D write /sys/class/android_usb/android0/functions mtp,adb write /sys/class/android_usb/android0/enable 1 setprop sys.usb.state ${sys.usb.config}# END 将/sys/class/android_usb/android0/idVendor和write /sys/class/android_usb/android0/idProduct后面的 id 分别替换到/config/usb_gadget/g1/idVendor和/config/usb_gadget/g1/idProduct处理完就是这样的。 12345678910111213141516on property:sys.usb.config=mtp,adb start adbdon property:sys.usb.ffs.ready=1 &amp;&amp; property:sys.usb.config=mtp,adb write /config/usb_gadget/g1/configs/b.1/strings/0x409/configuration &quot;mtp_adb&quot; rm /config/usb_gadget/g1/configs/b.1/f1 rm /config/usb_gadget/g1/configs/b.1/f2 rm /config/usb_gadget/g1/configs/b.1/f3 rm /config/usb_gadget/g1/configs/b.1/f4 rm /config/usb_gadget/g1/configs/b.1/f5 write /config/usb_gadget/g1/idVendor 0x2717 write /config/usb_gadget/g1/idProduct 0x904D symlink /config/usb_gadget/g1/functions/mtp.gs0 /config/usb_gadget/g1/configs/b.1/f1 symlink /config/usb_gadget/g1/functions/ffs.adb /config/usb_gadget/g1/configs/b.1/f2 write /config/usb_gadget/g1/UDC ${sys.usb.controller} setprop sys.usb.state ${sys.usb.config} 接下来开机之后 adb 和 mtp 就能同时工作了。 修复 Resetprop接下来就可以修复其它 bug 了，我看到控制台有一堆红色的报错: 123E:Unknown File System:'/mi_ext'E:Unable to override 'external_storage.projid.enabled' due to missing libresetprop挂载“/data”失败(Invalid argument) 这三个报错中第二个最好修，第一个次之，第三个与解密有关，放在另一个大章节讲。第二个报错只需要在 BoardConfig.mk 中添加 123# ToolTW_INCLUDE_RESETPROP := trueTW_INCLUDE_LIBRESETPROP := true 不用编译测试直接秒杀 修复挂载1E:Unknown File System:'/mi_ext' 我们打开 recovery/root/system/etc 中的 recovery.fstab，发现里面有很多空格，我们先将它格式化一下，有实力的可以把后面的 flag 也对齐整理好。我比较没实力，简单格式化了一下，是这样的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# 1 &quot;vendor/mediatek/proprietary/hardware/fstab/mt6895/fstab.in.mt6895&quot;# 1 &quot;&lt;built-in&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 3# 341 &quot;&lt;built-in&gt;&quot; 3# 1 &quot;&lt;command line&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 2# 1 &quot;vendor/mediatek/proprietary/hardware/fstab/mt6895/fstab.in.mt6895&quot; 2# 173 &quot;vendor/mediatek/proprietary/hardware/fstab/mt6895/fstab.in.mt6895&quot;system /system erofs ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeysystem /system ext4 ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeyvendor /vendor erofs ro wait,slotselect,avb,logical,first_stage_mountvendor /vendor ext4 ro wait,slotselect,avb,logical,first_stage_mountproduct /product erofs ro wait,slotselect,avb,logical,first_stage_mountproduct /product ext4 ro wait,slotselect,avb,logical,first_stage_mountmi_ext /mnt/vendor/mi_ext erofs ro wait,slotselect,avb=vbmeta,logical,first_stage_mount,nofailmi_ext /mnt/vendor/mi_ext ext4 ro wait,slotselect,avb=vbmeta,logical,first_stage_mount,nofail/mnt/vendor/mi_ext /mi_ext none ro,bind wait,nofailoverlay /product/overlay overlay ro,lowerdir=/mnt/vendor/mi_ext/product/overlay/:/product/overlay check,nofailoverlay /product/app overlay ro,lowerdir=/mnt/vendor/mi_ext/product/app/:/product/app check,nofailoverlay /product/priv-app overlay ro,lowerdir=/mnt/vendor/mi_ext/product/priv-app/:/product/priv-app check,nofailoverlay /product/lib overlay ro,lowerdir=/mnt/vendor/mi_ext/product/lib/:/product/lib check,nofailoverlay /product/lib64 overlay ro,lowerdir=/mnt/vendor/mi_ext/product/lib64/:/product/lib64 check,nofailoverlay /product/bin overlay ro,lowerdir=/mnt/vendor/mi_ext/product/bin/:/product/bin check,nofailoverlay /product/framework overlay ro,lowerdir=/mnt/vendor/mi_ext/product/framework/:/product/framework check,nofailoverlay /product/media overlay ro,lowerdir=/mnt/vendor/mi_ext/product/media/:/product/media check,nofailoverlay /product/opcust overlay ro,lowerdir=/mnt/vendor/mi_ext/product/opcust/:/product/opcust check,nofailoverlay /product/data-app overlay ro,lowerdir=/mnt/vendor/mi_ext/product/data-app/:/product/data-app check,nofailoverlay /product/etc/sysconfig overlay ro,lowerdir=/mnt/vendor/mi_ext/product/etc/sysconfig/:/product/etc/sysconfig check,nofailoverlay /product/etc/permissions overlay ro,lowerdir=/mnt/vendor/mi_ext/product/etc/permissions/:/product/etc/permissions check,nofailoverlay /system/app overlay ro,lowerdir=/mnt/vendor/mi_ext/system/app/:/product/pangu/system/app/:/system/app check,nofailoverlay /system/priv-app overlay ro,lowerdir=/mnt/vendor/mi_ext/system/priv-app/:/product/pangu/system/priv-app/:/system/priv-app check,nofailoverlay /system/framework overlay ro,lowerdir=/product/pangu/system/framework/:/system/framework check,nofailoverlay /system/etc/sysconfig overlay ro,lowerdir=/mnt/vendor/mi_ext/system/etc/sysconfig/:/system/etc/sysconfig check,nofailoverlay /system/etc/permissions overlay ro,lowerdir=/mnt/vendor/mi_ext/system/etc/permissions/:/product/pangu/system/etc/permissions/:/system/etc/permissions check,nofailsystem_ext /system_ext erofs ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeysystem_ext /system_ext ext4 ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeyodm /odm erofs ro wait,slotselect,avb,logical,first_stage_mountodm /odm ext4 ro wait,slotselect,avb,logical,first_stage_mountvendor_dlkm /vendor_dlkm erofs ro wait,slotselect,avb,logical,first_stage_mountodm_dlkm /odm_dlkm erofs ro wait,slotselect,avb,logical,first_stage_mount/dev/block/by-name/metadata /metadata ext4 noatime,nosuid,nodev,discard wait,check,formattable,first_stage_mount/dev/block/by-name/userdata /data f2fs noatime,nosuid,nodev,discard,noflush_merge,fsync_mode=nobarrier,reserve_root=134217,resgid=1065,checkpoint_merge,gc_merge,inlinecrypt wait,check,formattable,quota,latemount,resize,reservedsize=128m,checkpoint=fs,fileencryption=aes-256-xts:aes-256-cts:v2+inlinecrypt_optimized,keydirectory=/metadata/vold/metadata_encryption,fsverity/dev/block/by-name/rescue /cache ext4 noatime,nosuid,nodev,noauto_da_alloc,discard wait,check,formattable/dev/block/by-name/protect1 /mnt/vendor/protect_f ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/protect2 /mnt/vendor/protect_s ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/nvdata /mnt/vendor/nvdata ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/nvcfg /mnt/vendor/nvcfg ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/persist /mnt/vendor/persist ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/devices/platform/soc/11240000.mmc* auto auto defaults voldmanaged=sdcard1:auto,encryptable=userdata/devices/platform/usb_xhci* auto vfat defaults voldmanaged=usbotg:auto/devices/platform/soc/11201000.usb0/11200000.xhci* auto vfat defaults voldmanaged=usbotg:auto/dev/block/by-name/frp /persistent emmc defaults defaults/dev/block/by-name/nvram /nvram emmc defaults defaults/dev/block/by-name/proinfo /proinfo emmc defaults defaults/dev/block/by-name/lk /bootloader emmc defaults defaults/dev/block/by-name/lk2 /bootloader2 emmc defaults defaults/dev/block/by-name/para /para emmc defaults defaults/dev/block/by-name/misc /misc emmc defaults defaults/dev/block/by-name/boot /boot emmc defaults first_stage_mount,nofail,slotselect/dev/block/by-name/vbmeta_vendor /vbmeta_vendor emmc defaults first_stage_mount,nofail,slotselect/dev/block/by-name/vbmeta_system /vbmeta_system emmc defaults first_stage_mount,nofail,slotselect,avb=vbmeta/dev/block/by-name/logo /logo emmc defaults defaults/dev/block/by-name/expdb /expdb emmc defaults defaults/dev/block/by-name/seccfg /seccfg emmc defaults defaults/dev/block/by-name/tee1 /tee1 emmc defaults defaults/dev/block/by-name/tee2 /tee2 emmc defaults defaults/dev/block/by-name/scp1 /scp1 emmc defaults defaults/dev/block/by-name/scp2 /scp2 emmc defaults defaults/dev/block/by-name/sspm_1 /sspm_1 emmc defaults defaults/dev/block/by-name/sspm_2 /sspm_2 emmc defaults defaults/dev/block/by-name/dpm_1 /dpm_1 emmc defaults defaults/dev/block/by-name/dpm_2 /dpm_2 emmc defaults defaults/dev/block/by-name/mcupm_1 /mcupm_1 emmc defaults defaults/dev/block/by-name/mcupm_2 /mcupm_2 emmc defaults defaults/dev/block/by-name/md1img /md1img emmc defaults defaults/dev/block/by-name/md1dsp /md1dsp emmc defaults defaults/dev/block/by-name/md1arm7 /md1arm7 emmc defaults defaults/dev/block/by-name/md3img /md3img emmc defaults defaults/dev/block/by-name/gz1 /gz1 emmc defaults defaults/dev/block/by-name/gz2 /gz2 emmc defaults defaults/dev/block/by-name/spmfw /spmfw emmc defaults defaults/dev/block/by-name/audio_dsp /audio_dsp emmc defaults defaults/dev/block/by-name/pi_img /pi_img emmc defaults defaults/dev/block/by-name/boot_para /boot_para emmc defaults defaults/dev/block/by-name/odmdtbo /odmdtbo emmc defaults defaults/dev/block/by-name/dtbo /dtbo emmc defaults defaults/dev/block/by-name/otp /otp emmc defaults defaults/dev/block/by-name/vbmeta /vbmeta emmc defaults defaults 这里面有很多无用分区，我们在 twrp 中操作不到，但是我也是第一次适配 MTK 设备，所以不“瞎说”误人子弟了，先把 bug 修好。像 xiaomi 这样常见的挂载错误，我自己一般都是尝试把/mnt/vendor 使用 vscode 全部删除，让我们尝试一下。并且要把这一行删除，这行在我看来是重复定义（？而且也没指定分区格式。 1/mnt/vendor/mi_ext /mi_ext none ro,bind wait,nofail 整理完之后是这样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 1 &quot;vendor/mediatek/proprietary/hardware/fstab/mt6895/fstab.in.mt6895&quot;# 1 &quot;&lt;built-in&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 3# 341 &quot;&lt;built-in&gt;&quot; 3# 1 &quot;&lt;command line&gt;&quot; 1# 1 &quot;&lt;built-in&gt;&quot; 2# 1 &quot;vendor/mediatek/proprietary/hardware/fstab/mt6895/fstab.in.mt6895&quot; 2# 173 &quot;vendor/mediatek/proprietary/hardware/fstab/mt6895/fstab.in.mt6895&quot;system /system erofs ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeysystem /system ext4 ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeyvendor /vendor erofs ro wait,slotselect,avb,logical,first_stage_mountvendor /vendor ext4 ro wait,slotselect,avb,logical,first_stage_mountproduct /product erofs ro wait,slotselect,avb,logical,first_stage_mountproduct /product ext4 ro wait,slotselect,avb,logical,first_stage_mountmi_ext /mi_ext erofs ro wait,slotselect,avb=vbmeta,logical,first_stage_mount,nofailmi_ext /mi_ext ext4 ro wait,slotselect,avb=vbmeta,logical,first_stage_mount,nofailoverlay /product/overlay overlay ro,lowerdir=/mi_ext/product/overlay/:/product/overlay check,nofailoverlay /product/app overlay ro,lowerdir=/mi_ext/product/app/:/product/app check,nofailoverlay /product/priv-app overlay ro,lowerdir=/mi_ext/product/priv-app/:/product/priv-app check,nofailoverlay /product/lib overlay ro,lowerdir=/mi_ext/product/lib/:/product/lib check,nofailoverlay /product/lib64 overlay ro,lowerdir=/mi_ext/product/lib64/:/product/lib64 check,nofailoverlay /product/bin overlay ro,lowerdir=/mi_ext/product/bin/:/product/bin check,nofailoverlay /product/framework overlay ro,lowerdir=/mi_ext/product/framework/:/product/framework check,nofailoverlay /product/media overlay ro,lowerdir=/mi_ext/product/media/:/product/media check,nofailoverlay /product/opcust overlay ro,lowerdir=/mi_ext/product/opcust/:/product/opcust check,nofailoverlay /product/data-app overlay ro,lowerdir=/mi_ext/product/data-app/:/product/data-app check,nofailoverlay /product/etc/sysconfig overlay ro,lowerdir=/mi_ext/product/etc/sysconfig/:/product/etc/sysconfig check,nofailoverlay /product/etc/permissions overlay ro,lowerdir=/mi_ext/product/etc/permissions/:/product/etc/permissions check,nofailoverlay /system/app overlay ro,lowerdir=/mi_ext/system/app/:/product/pangu/system/app/:/system/app check,nofailoverlay /system/priv-app overlay ro,lowerdir=/mi_ext/system/priv-app/:/product/pangu/system/priv-app/:/system/priv-app check,nofailoverlay /system/framework overlay ro,lowerdir=/product/pangu/system/framework/:/system/framework check,nofailoverlay /system/etc/sysconfig overlay ro,lowerdir=/mi_ext/system/etc/sysconfig/:/system/etc/sysconfig check,nofailoverlay /system/etc/permissions overlay ro,lowerdir=/mi_ext/system/etc/permissions/:/product/pangu/system/etc/permissions/:/system/etc/permissions check,nofailsystem_ext /system_ext erofs ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeysystem_ext /system_ext ext4 ro wait,slotselect,avb=vbmeta_system,logical,first_stage_mount,avb_keys=/avb/q-gsi.avbpubkey:/avb/r-gsi.avbpubkey:/avb/s-gsi.avbpubkeyodm /odm erofs ro wait,slotselect,avb,logical,first_stage_mountodm /odm ext4 ro wait,slotselect,avb,logical,first_stage_mountvendor_dlkm /vendor_dlkm erofs ro wait,slotselect,avb,logical,first_stage_mountodm_dlkm /odm_dlkm erofs ro wait,slotselect,avb,logical,first_stage_mount/dev/block/by-name/metadata /metadata ext4 noatime,nosuid,nodev,discard wait,check,formattable,first_stage_mount/dev/block/by-name/userdata /data f2fs noatime,nosuid,nodev,discard,noflush_merge,fsync_mode=nobarrier,reserve_root=134217,resgid=1065,checkpoint_merge,gc_merge,inlinecrypt wait,check,formattable,quota,latemount,resize,reservedsize=128m,checkpoint=fs,fileencryption=aes-256-xts:aes-256-cts:v2+inlinecrypt_optimized,keydirectory=/metadata/vold/metadata_encryption,fsverity/dev/block/by-name/rescue /cache ext4 noatime,nosuid,nodev,noauto_da_alloc,discard wait,check,formattable/dev/block/by-name/protect1 /protect_f ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/protect2 /protect_s ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/nvdata /nvdata ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/nvcfg /nvcfg ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/dev/block/by-name/persist /persist ext4 noatime,nosuid,nodev,noauto_da_alloc,commit=1,nodelalloc wait,check,formattable/devices/platform/soc/11240000.mmc* auto auto defaults voldmanaged=sdcard1:auto,encryptable=userdata/devices/platform/usb_xhci* auto vfat defaults voldmanaged=usbotg:auto/devices/platform/soc/11201000.usb0/11200000.xhci* auto vfat defaults voldmanaged=usbotg:auto/dev/block/by-name/frp /persistent emmc defaults defaults/dev/block/by-name/nvram /nvram emmc defaults defaults/dev/block/by-name/proinfo /proinfo emmc defaults defaults/dev/block/by-name/lk /bootloader emmc defaults defaults/dev/block/by-name/lk2 /bootloader2 emmc defaults defaults/dev/block/by-name/para /para emmc defaults defaults/dev/block/by-name/misc /misc emmc defaults defaults/dev/block/by-name/boot /boot emmc defaults first_stage_mount,nofail,slotselect/dev/block/by-name/vbmeta_vendor /vbmeta_vendor emmc defaults first_stage_mount,nofail,slotselect/dev/block/by-name/vbmeta_system /vbmeta_system emmc defaults first_stage_mount,nofail,slotselect,avb=vbmeta/dev/block/by-name/logo /logo emmc defaults defaults/dev/block/by-name/expdb /expdb emmc defaults defaults/dev/block/by-name/seccfg /seccfg emmc defaults defaults/dev/block/by-name/tee1 /tee1 emmc defaults defaults/dev/block/by-name/tee2 /tee2 emmc defaults defaults/dev/block/by-name/scp1 /scp1 emmc defaults defaults/dev/block/by-name/scp2 /scp2 emmc defaults defaults/dev/block/by-name/sspm_1 /sspm_1 emmc defaults defaults/dev/block/by-name/sspm_2 /sspm_2 emmc defaults defaults/dev/block/by-name/dpm_1 /dpm_1 emmc defaults defaults/dev/block/by-name/dpm_2 /dpm_2 emmc defaults defaults/dev/block/by-name/mcupm_1 /mcupm_1 emmc defaults defaults/dev/block/by-name/mcupm_2 /mcupm_2 emmc defaults defaults/dev/block/by-name/md1img /md1img emmc defaults defaults/dev/block/by-name/md1dsp /md1dsp emmc defaults defaults/dev/block/by-name/md1arm7 /md1arm7 emmc defaults defaults/dev/block/by-name/md3img /md3img emmc defaults defaults/dev/block/by-name/gz1 /gz1 emmc defaults defaults/dev/block/by-name/gz2 /gz2 emmc defaults defaults/dev/block/by-name/spmfw /spmfw emmc defaults defaults/dev/block/by-name/audio_dsp /audio_dsp emmc defaults defaults/dev/block/by-name/pi_img /pi_img emmc defaults defaults/dev/block/by-name/boot_para /boot_para emmc defaults defaults/dev/block/by-name/odmdtbo /odmdtbo emmc defaults defaults/dev/block/by-name/dtbo /dtbo emmc defaults defaults/dev/block/by-name/otp /otp emmc defaults defaults/dev/block/by-name/vbmeta /vbmeta emmc defaults defaults 让我们编译试一下，值得注意的是，twrp 每次更改最好删除 out 重新编译，不要使用如make installclean等命令，可能会开机黑屏或更改不生效。经过一分钟，编译好了，刷入，开机，启动！可以看见挂载成功被修好。 修复屏幕显示可以看到我们现在屏幕的顶部的时间被摄像头挖孔挡住了。我们使用两个偏移 Flag 来修复它。在 BoardConfig.mk 中，加入以下 flag 12TW_Y_OFFSET := 106 #导航栏向上TW_H_OFFSET := -106 #界面整体向下 修复振动 仅供参考，研究半天发现只有解密功能正常才能修振动，不然会冻屏！！！不一定正确，也不一定普遍，仅供指路 老设备一般都是正常的，不需要额外处理，新设备使用 aidl hal 需要我们自己处理一下让 service 正常工作。挂载 vendor，使用 twrp 的文件管理，在 vendor/etc/vintf/manifest 找到含有 vibrator 字样的文件。打开之后检查是否类似这样的文段 123456&lt;manifest version=&quot;1.0&quot; type=&quot;device&quot;&gt; &lt;hal format=&quot;aidl&quot; override=&quot;true&quot;&gt; &lt;name&gt;android.hardware.vibrator&lt;/name&gt; &lt;fqname&gt;IVibrator/vibratorfeature&lt;/fqname&gt; &lt;/hal&gt;&lt;/manifest&gt; 那恭喜你，找对了，我的文件名是vendor.xiaomi.hardware.vibratorfeature.service.xml将它使用adb pull放到电脑上自己方便的位置备用。 12xiaolegun@xiaoleGundeMac-Pro  ~/github/$/mjw  adb pull /vendor/etc/vintf/manifest/vendor.xiaomi.hardware.vibratorfeature.service.xml ./vendor/etc/vintf/manifest/vendor.xiao...ipped. 0.2 MB/s (1718 bytes in 0.009s) 不看扩展名，到 vendor/bin/hw/找到同名的 service 同样利用adb pull放电脑备用。比如我的叫vendor.xiaomi.hardware.vibratorfeature.service然后到 vendor/etc/init/找到同名.rc 文件，拉到电脑上，在里面加一条。并在定义 service 的最下面加上seclabel u:r:recovery:s0可以被 recovery 使用。 12on boot start service被定义的名字 例如 123456789101112131415on post-fs-data chown system system /sys/bus/i2c/drivers/aw8697_haptic/2-005a/f0_save chown system system /sys/bus/i2c/drivers/aw8697_haptic/2-005a/osc_save chown system system /sys/bus/i2c/drivers/aw8697_haptic/3-005a/osc_save # 省略一万字on boot start vibratorfeature-hal-serviceservice vibratorfeature-hal-service /vendor/bin/hw/vendor.xiaomi.hardware.vibratorfeature.service class hal user system group system input onrestart restart vibratorfeature seclabel u:r:recovery:s0 此外这种新设备在内核里还有振动模块需要加载，请到/vendor/modules/1.1/中寻找，例如我这台设备是haptic.ko，用 adb pull 拉取到电脑上，然后 haptic.ko –&gt; recovery/root/vendor/modules/1.1 至此所有必要的资料就准备好了。可能开机后仍然不工作，需要抓取 log 补缺失的 library，当然这是后话了。 开干！ 在 BoardConfig.mk 中加入以下 flag 1TW_SUPPORT_INPUT_AIDL_HAPTICS := true 将备用文件按照以下操作复制 vendor.xiaomi.hardware.vibratorfeature.service.xml –&gt; recovery/root/vendor/etc/vintf/manifest vendor.xiaomi.hardware.vibratorfeature.service –&gt; recovery/root/vendor/bin/hw vendor.xiaomi.hardware.vibratorfeature.service.rc –&gt; recovery/root/vendor/etc/init 之后编译，刷入，开机，喜提冻屏……问题不大，使用adb logcat抓取日志 1adb logcat &gt; log.log 打开 log，搜索F linker、linker、library、beginning of crash这几个关键词，我搜索第一个就出来了。 1F linker : CANNOT LINK EXECUTABLE &quot;/vendor/bin/hw/vendor.xiaomi.hardware.vibratorfeature.service&quot;: library &quot;android.hardware.vibrator-V1-ndk_platform.so&quot; not found: needed by main executable 这段报错的意思就是vendor.xiaomi.hardware.vibratorfeature.service找不到android.hardware.vibrator-V1-ndk_platform.so这个库，所以无法正常工作。 打开 BoardConfig.mk 加入以下 flag 123456# LibraryTARGET_RECOVERY_DEVICE_MODULES += \\ android.hardware.vibrator-V1-ndk_platform.vendorTW_RECOVERY_ADDITIONAL_RELINK_LIBRARY_FILES += \\ $(TARGET_OUT_SHARED_LIBRARIES)/android.hardware.vibrator-V1-ndk_platform.so 再次编译尝试开机之后依然冻屏，继续抓 log，查找 1F linker : CANNOT LINK EXECUTABLE &quot;/vendor/bin/hw/vendor.xiaomi.hardware.vibratorfeature.service&quot;: library &quot;vendor.hardware.vibratorfeature.IVibratorExt-V1-ndk_platform.so&quot; not found: needed by main executable vendor.hardware.vibratorfeature字样和我们之前导入的文件长得差不多，一般都是供应商专有文件，所以去设备提取，路径在 vendor/lib64 里，虽然设备冻屏了，但我们可以用adb pull直接拉取到电脑。就像这样。 123xiaolegun@xiaoleGundeMac-Pro  ~/github/$/mjw  adb shell mount /vendorxiaolegun@xiaoleGundeMac-Pro  ~/github/$/mjw  adb pull /vendor/lib64/vendor.hardware.vibratorfeature.IVibratorExt-V1-ndk_platform.so ./vendor/lib64/vendor.hardware.vibratorfeature.IVi...led, 0 skipped. 14.7 MB/s (33552 bytes in 0.002s 将这个文件按照以下提示操作 vendor.hardware.vibratorfeature.IVibratorExt-V1-ndk_platform.so –&gt; recovery/root/vendor/lib64 继续编译测试还是冻屏，继续抓 log 1F linker : CANNOT LINK EXECUTABLE &quot;/vendor/bin/hw/vendor.xiaomi.hardware.vibratorfeature.service&quot;: library &quot;libtinyalsa.so&quot; not found: needed by main executable 这个 library twrp 的源码中应该没有，去设备拿一个 prebuilt 吧 123xiaolegun@xiaoleGundeMac-Pro  ~/github/$/mjw  adb shell mount /system_rootxiaolegun@xiaoleGundeMac-Pro  ~/github/$/mjw  adb pull /system_root/system/lib64/libtinyalsa.so ./system_root/system/lib64/libtinyalsa.so: 1 file ...led, 0 skipped. 13.6 MB/s (45032 bytes in 0.003s 将这个文件按照以下提示操作 libtinyalsa.so –&gt; recovery/root/system/lib64 编译测试我艹了，还是冻屏，这次搜那几个关键词都搜不到了，搜vibrator看看这鬼东西报什么 1E vendor.xiaomi.hardware.vibratorfeature.service: fail to load lib : /vendor/lib64/libaachaptics.so 这次都直接给路径了，直接拿。 123xiaolegun@xiaoleGundeMac-Pro  ~/github/$/mjw  adb shell mount /vendorxiaolegun@xiaoleGundeMac-Pro  ~/github/$/mjw  adb pull /vendor/lib64/libaachaptics.so ./vendor/lib64/libaachaptics.so: 1 file pulled, 0 skipped. 15.8 MB/s (56232 bytes in 0.003s) 将这个文件按照以下提示操作 libaachaptics.so –&gt; recovery/root/vendor/lib64 至此应该没什么问题了，但是有个 flag 貌似要操作 data 内的东西，未解密会导致冻屏，所以等修完解密后再来修振动。 修复 CPU 温度使用adb shell + grep命令在手机节点里搜索 type 关键词。 123456789101112131415xiaolegun@xiaoleGundeMac-Pro  ~  adb shell 'grep &quot;cp_master&quot; /sys/class/thermal/*/type'/sys/class/thermal/thermal_zone54/type:cp_masterxiaolegun@xiaoleGundeMac-Pro  ~  adb shell 'grep &quot;cpu&quot; /sys/class/thermal/*/type'/sys/class/thermal/thermal_zone1/type:cpu_little1/sys/class/thermal/thermal_zone10/type:cpu_bigbig1/sys/class/thermal/thermal_zone11/type:cpu_big6/sys/class/thermal/thermal_zone12/type:cpu_bigbig2/sys/class/thermal/thermal_zone2/type:cpu_little2/sys/class/thermal/thermal_zone3/type:cpu_little3/sys/class/thermal/thermal_zone4/type:cpu_little4/sys/class/thermal/thermal_zone5/type:cpu_big1/sys/class/thermal/thermal_zone6/type:cpu_big2/sys/class/thermal/thermal_zone7/type:cpu_big3/sys/class/thermal/thermal_zone8/type:cpu_big4/sys/class/thermal/thermal_zone9/type:cpu_big5 我这里选用cp_master节点来读取温度。我的节点路径为/sys/class/thermal/thermal_zone54在后面添加 temp 来读取温度，你可以使用cat来检测节点是否可以正常读取温度 1adb shell 'cat /sys/class/thermal/thermal_zone54/temp' 如果返回如 128000 这种类似的数值，那多半是没有问题的。我们在 BoardConfig.mk 中加入 1TW_CUSTOM_CPU_TEMP_PATH := &quot;/sys/class/thermal/thermal_zone54/temp&quot; 至此 cpu 温度就修复好了。 后序这是我玩 Android 两年内第一次写关于 Android 的文章，内容和措辞可能不是很准确，再加上开学焦虑，租房因租金和房源不顺利，写的很乱，请各位指正。解密等有空补，先补作业。 参考资料Google - 添加新设备 Google - A/B（无缝）系统更新 Lynnrin - 快速上手 Android Custom ROM 适配 - Prebuilt Vendor Google - 供应商接口对象","link":"/post/writing-recovery-device-tree-for-new-device/"}],"tags":[{"name":"GSI","slug":"GSI","link":"/tags/GSI/"},{"name":"ROM","slug":"ROM","link":"/tags/ROM/"}],"categories":[],"pages":[{"title":"","text":"Hi there 👋 I’m xiaoleGun 🌱 I’m learning Android~ 📫 Email: xiaolegun@qq.com 🏠 I’m a junior high school student of Beijing Yanqing No.4 middle school. A staunch communist “尊严只在剑锋之上，真理只在大炮射程之内” 🎵 Spotify 💻 Environment 📱 Devices","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}]}